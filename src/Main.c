#pragma config(Sensor, in1,    LeftPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in2,    RightPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in3,    MiniliftPotentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  JumperClip,     sensorDigitalIn)
#pragma config(Sensor, dgtl2,  JumperClip2,    sensorDigitalIn)
#pragma config(Sensor, dgtl5,  RightBumper,    sensorTouch)
#pragma config(Sensor, dgtl6,  LeftBumper,     sensorTouch)
#pragma config(Sensor, dgtl7,  RightLED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  LeftLED,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  RightQuad1,     sensorQuadEncoder)
#pragma config(Sensor, dgtl11, LeftQuad1,      sensorQuadEncoder)
#pragma config(Motor,  port2,           DriveFL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           DriveFR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LiftR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LiftL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           BallLauncher,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           MiniLift,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           DriveBL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           DriveBR,       tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                      Autonomous Functions and Tasks                       */
/*                                                                           */

/*---------------------------------------------------------------------------*/

	//Blink Right LED
	 task blinkRightLED()
	 {
	  SensorValue[RightLED] = 0;
	  wait1Msec(100);
	  SensorValue[RightLED] = 1;
	  wait1Msec(100);
	}


	// Blink Left LED
	task blinkLeftLED()
	{
		SensorValue[LeftLED] = 0;
		wait1Msec(100);
		SensorValue[LeftLED] = 1;
		wait1Msec(100);
	}


	// Drive Forwards
	void drive_forwards(float inches)
	{
		SensorValue[RightQuad1] = 0;
		float distance = SensorValue[RightQuad1] * 0.03491;

		while(distance < inches){
			setMultipleMotors(100, DriveFR, DriveBR, DriveFL, DriveBL);
		}
		setMultipleMotors(0, DriveFR, DriveBR, DriveFL, DriveBL);
	}


	// Drive Backwards
	void drive_backwards(float inches)
	{
		SensorValue[RightQuad1] = 0;
		float distance = SensorValue[RightQuad1] * -0.03491;

		while(distance < inches){
			setMultipleMotors(100, DriveFR, DriveBR, DriveFL, DriveBL);
		}
		setMultipleMotors(0, DriveFR, DriveBR, DriveFL, DriveBL);
	}


	// Turn Left
	void turn_left(int time)
	{
		setMultipleMotors(-100, DriveFR, DriveBR);
		setMultipleMotors(100, DriveFL, DriveBL);
		wait1Msec(time);
		setMultipleMotors(0, DriveFR, DriveBR, DriveFL, DriveBL);
	}


  // Turn Right
	void turn_right(int time)
	{
		setMultipleMotors(100, DriveFR, DriveBR);
		setMultipleMotors(-100, DriveFL, DriveBL);
		wait1Msec(time);
		setMultipleMotors(0, DriveFR, DriveBR, DriveFL, DriveBL);
	}


	// Minilift Up
	void ballShooterUp(int angle)
	{
		int currentAngle;

		while(currentAngle < angle)
		{
			currentAngle = SensorValue[MiniliftPotentiometer] * 0.06471306471;
			setMotor(MiniLift, -50);
		}
		setMotor(MiniLift, 0);

	}


	// Minilift Down
	void ballShooterDown(int angle)
	{
		int currentAngle;

		while(currentAngle < angle)
		{
			currentAngle = SensorValue[MiniliftPotentiometer] * -0.06471306471;
			setMotor(MiniLift, 50);
		}
		setMotor(MiniLift, 0);

	}


	// Shoot Ball
	void shoot_ball()
	{
		setMotor(BallLauncher, -127);
		wait1Msec(2000);
		setMotor(BallLauncher, 0);
	}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                         Driver Control Functions                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/

  // Minilift Function
  void ballShooterLift()
  {
  	if(vexRT(Btn5U) == 1)
  	{
			setMotor(MiniLift, -50);
		}
		else if(vexRT(Btn5D) == 1)
		{
			setMotor(MiniLift, 30);
		}
		else
		{
			setMotor(MiniLift, 0);
		}
  }


  // Ball Shooter Function
  void ballShooter(){
  	if(vexRT(Btn7D))
		{
			setMotor(BallLauncher, -127);
		}
		else
		{
			setMotor(BallLauncher, 0);
		}
	}


  // Lift Angle Correction Function
  void correctLift(int Left, int Right)
  {
  	setMotor(LiftL, 0);

  	if(Right > Left)
  	{
  		setMotor(LiftR, 20);
  	}
  	else if(Left > Right)
  	{
  		setMotor(LiftR, -20);
  	}
  	else
  	{
  		setMotor(LiftR, 0);
  	}
	}


  // Lift Function
  void lift(int Left, int Right)
  {
  	if(vexRT(Btn6U) == 1)
		{
			setMotor(LiftR, 127);
			setMotor(LiftL, -127);
		}
		else if(vexRT(Btn6D) == 1)
		{
			setMotor(LiftR, -127);
			setMotor(LiftL, 127);
		}
		else
		{
			setMotor(LiftR, 0);
			setMotor(LiftL, 0);
		}
		correctLift(Left, Right);
  }


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	int jumper = SensorValue[JumperClip];

	if(jumper == 0){
		startTask(blinkLeftLED);
	}
	else{
		startTask(blinkRightLED);
	}

  bStopTasksBetweenModes = true;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	int jumper = SensorValue[JumperClip];
	int side = SensorValue[JumperClip2];

	// Near Square
	if(jumper == 0)
	{
		setMotor(MiniLift, 30);
  	wait1Msec(750);
 		setMotor(MiniLift, 0);
  	delay(10);
  	setMotor(BallLauncher, -127);
  	wait(2.75);
  	setMotor(BallLauncher, 0);
	}

	// Far Square
	else
	{

		//Red
		if(side == 0)
		{
			ballShooterDown(100);
			wait1Msec(250);
			shoot_ball();
			wait1Msec(100);
			ballShooterUp(0);
			wait(100);
			drive_forwards(42);
			wait1Msec(250);
			drive_backwards(66);
			wait1Msec(250);
			turn_right(500);
			wait1Msec(250);
			drive_forwards(42);
		}

		//Blue
		else
		{
			ballShooterDown(100);
			wait1Msec(250);
			ballShooterUp(0);
			wait(100);
			shoot_ball();
			wait1Msec(100);
			drive_forwards(42);
			wait1Msec(250);
			drive_backwards(66);
			wait1Msec(250);
			turn_left(500);
			wait1Msec(250);
			drive_forwards(42);
		}

	}

}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

task usercontrol()
{

  while (true)
  {
  	// Drivetrain
		motor[port2] = vexRT(Ch3);
  	motor[port3] = vexRT(Ch2);
  	motor[port8] = vexRT(Ch3);
  	motor[port9] = vexRT(Ch2);


  	// Minilift
  	ballShooterLift();


		// Ball Shooter
		ballShooter();


  	// Lift
		int LiftRight = SensorValue[RightPotentiometer] * 0.06471306471;
		int LiftLeft = SensorValue[LeftPotentiometer] * 0.06471306471;
		lift(LiftLeft, LiftRight);
  }

}
